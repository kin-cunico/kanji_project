{
  "version": 3,
  "sources": ["../../vivus/dist/vivus.js"],
  "sourcesContent": ["/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n(function () {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element instanceof window.SVGElement || \n      element instanceof window.SVGGElement ||\n      /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage.\n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n\n  newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n      x      = parseFloat(element.x)      || 0,\n      y      = parseFloat(element.y)      || 0,\n      width  = parseFloat(element.width)  || 0,\n      height = parseFloat(element.height) || 0;\n\n  if (element.rx || element.ry) {\n    var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n    rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width/2);\n    ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height/2);\n\n    newElement.d = 'M ' + (x + rx) + ',' + y + ' ' +\n                   'L ' + (x + width - rx) + ',' + y + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' +\n                   'L ' + (x + width) + ',' + (y + height - ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' +\n                   'L ' + (x + rx) + ',' + (y + height) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' +\n                   'L ' + x + ',' + (y + ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n  }\n  else {\n    newElement.d = 'M' + x + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + (y + height) + ' ' +\n                   'L' + x + ' ' + (y + height) + ' Z';\n  }\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var newElement = {},\n      points = element.points.trim().split(' '),\n      i, path;\n\n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {},\n      r  = parseFloat(element.r)  || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n      \n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'sync'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus(element, options, callback) {\n  setupEnv();\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n **************************************\n *\n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR = function(x) {\n  return x;\n};\nVivus.EASE = function(x) {\n  return -Math.cos(x * Math.PI) / 2 + 0.5;\n};\nVivus.EASE_OUT = function(x) {\n  return 1 - Math.pow(1 - x, 3);\n};\nVivus.EASE_IN = function(x) {\n  return Math.pow(x, 3);\n};\nVivus.EASE_OUT_BOUNCE = function(x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base, 1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n  return 1 - rateR + progress * rateR;\n};\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function(element, options) {\n  var onLoad, self;\n\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not related to an existing ID'\n      );\n    }\n  }\n  this.parentEl = element;\n\n  // Load the SVG with XMLHttpRequest and extract the SVG\n  if (options && options.file) {\n    self = this;\n    onLoad = function() {\n      var domSandbox = document.createElement('div');\n      domSandbox.innerHTML = this.responseText;\n\n      var svgTag = domSandbox.querySelector('svg');\n      if (!svgTag) {\n        throw new Error(\n          'Vivus [load]: Cannot find the SVG in the loaded file : ' +\n            options.file\n        );\n      }\n\n      self.el = svgTag;\n      self.el.setAttribute('width', '100%');\n      self.el.setAttribute('height', '100%');\n      self.parentEl.appendChild(self.el);\n      self.isReady = true;\n      self.init();\n      self = null;\n    };\n\n    var oReq = new window.XMLHttpRequest();\n    oReq.addEventListener('load', onLoad);\n    oReq.open('GET', options.file);\n    oReq.send();\n    return;\n  }\n\n  switch (element.constructor) {\n    case window.SVGSVGElement:\n    case window.SVGElement:\n    case window.SVGGElement:\n      this.el = element;\n      this.isReady = true;\n      break;\n\n    case window.HTMLObjectElement:\n      self = this;\n      onLoad = function(e) {\n        if (self.isReady) {\n          return;\n        }\n        self.el =\n          element.contentDocument &&\n          element.contentDocument.querySelector('svg');\n        if (!self.el && e) {\n          throw new Error(\n            'Vivus [constructor]: object loaded does not contain any SVG'\n          );\n        } else if (self.el) {\n          if (element.getAttribute('built-by-vivus')) {\n            self.parentEl.insertBefore(self.el, element);\n            self.parentEl.removeChild(element);\n            self.el.setAttribute('width', '100%');\n            self.el.setAttribute('height', '100%');\n          }\n          self.isReady = true;\n          self.init();\n          self = null;\n        }\n      };\n\n      if (!onLoad()) {\n        element.addEventListener('load', onLoad);\n      }\n      break;\n\n    default:\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)'\n      );\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function(options) {\n  var allowedTypes = [\n    'delayed',\n    'sync',\n    'async',\n    'nsync',\n    'oneByOne',\n    'scenario',\n    'scenario-sync'\n  ];\n  var allowedStarts = ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error(\n      'Vivus [constructor]: \"options\" parameter must be an object'\n    );\n  } else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.type +\n        ' is not an existing animation `type`'\n    );\n  } else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.start +\n        ' is not an existing `start` option'\n    );\n  } else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE =\n    window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n    window.navigator.userAgent.indexOf('Trident/') !== -1 ||\n    window.navigator.userAgent.indexOf('Edge/') !== -1;\n  this.duration = parsePositiveInt(options.duration, 120);\n  this.delay = parsePositiveInt(options.delay, null);\n  this.dashGap = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender')\n    ? !!options.forceRender\n    : this.isIE;\n  this.reverseStack = !!options.reverseStack;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady = options.onReady;\n  this.map = [];\n  this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible')\n    ? !!options.ignoreInvisible\n    : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function(callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error(\n      'Vivus [constructor]: \"callback\" parameter must be a function'\n    );\n  }\n  this.callback = callback || function() {};\n};\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function() {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n  hasNonScale = false;\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n\n    pathObj = {\n      el: path,\n      length: 0,\n      startAt: 0,\n      duration: 0,\n      isResizeSensitive: false\n    };\n\n    // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n    // so we need to calculate the scale and apply it\n    if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n      var rect = path.getBoundingClientRect();\n      var box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.isResizeSensitive = true;\n      hasNonScale = true;\n    } else {\n      scale = 1;\n    }\n    pathObj.length = Math.ceil(path.getTotalLength() * scale);\n\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn(\n          'Vivus [mapping]: cannot retrieve a path element length',\n          path\n        );\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray =\n      pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  // Show a warning for non-scaling elements\n  if (hasNonScale) {\n    console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  // Reverse stack if asked\n  if (this.reverseStack) {\n    this.map.reverse();\n  }\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n      case 'delayed':\n        pathObj.startAt = this.delayUnit * i;\n        pathObj.duration = this.duration - this.delay;\n        break;\n\n      case 'oneByOne':\n        pathObj.startAt = (lengthMeter / totalLength) * this.duration;\n        pathObj.duration = (pathObj.length / totalLength) * this.duration;\n        break;\n\n      case 'sync':\n      case 'async':\n      case 'nsync':\n        pathObj.startAt = 0;\n        pathObj.duration = this.duration;\n        break;\n\n      case 'scenario-sync':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          timePoint +\n          (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        timePoint =\n          pAttrs['data-async'] !== undefined\n            ? pathObj.startAt\n            : pathObj.startAt + pathObj.duration;\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n\n      case 'scenario':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Public method to re-evaluate line length for non-scaling lines\n * path elements.\n */\nVivus.prototype.recalc = function () {\n  if (this.mustRecalcScale) {\n    return;\n  }\n  this.mustRecalcScale = requestAnimFrame(function () {\n    this.performLineRecalc();\n  }.bind(this));\n}\n\n/**\n * Private method to re-evaluate line length on non-scaling\n * path elements. Then call for a trace to update the SVG. \n */\nVivus.prototype.performLineRecalc = function () {\n  var pathObj, path, rect, box, scale;\n  for (var i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n    if (pathObj.isResizeSensitive) {\n      path = pathObj.el;\n      rect = path.getBoundingClientRect();\n      box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.length = Math.ceil(path.getTotalLength() * scale);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    }\n  }\n  this.trace();\n  this.mustRecalcScale = null;\n}\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.draw = function() {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function() {\n      self.draw();\n    });\n    return;\n  }\n\n  this.callback(this);\n  if (this.instanceCallback) {\n    this.instanceCallback(this);\n    this.instanceCallback = null;\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function() {\n  var i, progress, path, currentFrame;\n  currentFrame =\n    this.animTimingFunction(this.currentFrame / this.frameLength) *\n    this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n *\n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function(index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n      newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n *\n */\nVivus.prototype.init = function() {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function() {\n  switch (this.start) {\n    case 'manual':\n      return;\n\n    case 'autostart':\n      this.play();\n      break;\n\n    case 'inViewport':\n      var self = this,\n        listener = function() {\n          if (self.isInViewport(self.parentEl, 1)) {\n            self.play();\n            window.removeEventListener('scroll', listener);\n          }\n        };\n      window.addEventListener('scroll', listener);\n      listener();\n      break;\n  }\n};\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function() {\n  return this.currentFrame === 0\n    ? 'start'\n    : this.currentFrame === this.frameLength\n    ? 'end'\n    : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function() {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function() {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n *\n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function(progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function(speed, callback) {\n  this.instanceCallback = null;\n\n  if (speed && typeof speed === 'function') {\n    this.instanceCallback = speed; // first parameter is actually the callback function\n    speed = null;\n  } else if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  // if the first parameter wasn't the callback, check if the seconds was\n  if (callback && typeof callback === 'function' && !this.instanceCallback) {\n    this.instanceCallback = callback;\n  }\n\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.draw();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function() {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function() {\n  this.stop();\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function(el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function(element) {\n  var attr,\n    output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function(el, h) {\n  var scrolled = this.scrollY(),\n    viewed = scrolled + this.getViewportH(),\n    elBCR = el.getBoundingClientRect(),\n    elHeight = elBCR.height,\n    elTop = scrolled + elBCR.top,\n    elBottom = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n};\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function() {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  } else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function() {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\nsetupEnv = function() {\n  if (Vivus.prototype.docElem) {\n    return;\n  }\n\n  /**\n   * Alias for document element\n   *\n   * @type {DOMelement}\n   */\n  Vivus.prototype.docElem = window.document.documentElement;\n\n  /**\n   * Alias for `requestAnimationFrame` or\n   * `setTimeout` function for deprecated browsers.\n   *\n   */\n  requestAnimFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(/* function */ callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  /**\n   * Alias for `cancelAnimationFrame` or\n   * `cancelTimeout` function for deprecated browsers.\n   *\n   */\n  cancelAnimFrame = (function() {\n    return (\n      window.cancelAnimationFrame ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame ||\n      window.oCancelAnimationFrame ||\n      window.msCancelAnimationFrame ||\n      function(id) {\n        return window.clearTimeout(id);\n      }\n    );\n  })();\n};\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function(value, defaultValue) {\n  var output = parseInt(value, 10);\n  return output >= 0 ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}());\n\n"],
  "mappings": "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",
  "names": []
}
